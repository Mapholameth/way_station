
# Системы Искусственного Интеллекта

## Лекция 1

### Литература 
  
  - Art of Prolog
  - Норвиг ""

Дополнительная информация про пролог. Неполные структуры.
Разностные списки.

    append(L1, L2, L):

      112 ?- append([1, 2], [3, 4], L).
      L = [1, 2, 3, 4].

    [a, b, c | X] - открытый (неполный) список

    X = [d, e, f]
    X = [d | X1]

    > open_append([H1, H2, H3 | Hole])

    open_append([H1, H2, H3 | Hole], L2) :-
      Hole = L2.

    diff_append(OpenList, Hole, L2) :-
      Hole = L2.

    %% ¿118 ?- diff_append([a, b, c|Hole], Hole, [d,e,f]).
    %% Hole = [d, e, f].

разностный список - результат "вычитания" из заданного списка заданного аргумента.

То есть представление списка как отрезание суффикса.

    [a, b] \ [b]
    dl([a, b], [b])
    [a, b] - [b]

- формальное обозначение для текстуальной записи.

L\L - пустой список

    difference_append(OpenList | Hole, L2, OpenList) :-
      Hole = L2.

    diff_list(OpenList|Hole1, OpenList2|Hole2, OpenList1) :-
      Hole1 = OpenList2.

    diff_append(OpenList1 | Hole1, OpenList2 | Hole2, OpenList1 | Hole2) :-
      Hole1 = OpenList2.

    dl([X|Y], Y).

    append(X\Y, Y\Z, X\Z)

    reverse(L, RL).
    reverse([H|T], RL) :-
      reverse(T, RT),
      append(RT, [H], RL).
    reverse([], []).

    reverse(L, RL) :- reverse(L, [], RL).
    reverse(L, A, RL).
    reverse([H|T], A, RL) :-
      reverse(T, [H|A], RL).
    reverse([], RL, RL).

    reverse_dl([H|T], dl(RL, Hole)) :-
      reverse_dl(T, dl(RL, [H|Hole])).
    reverse_dl([], dl(RL, RL)).

## Домашняя Задача 1 ##
### Проблема Голландского Флага ###
Имеются раскрашенные элементы и нужно их соответственно упорядочить.
[red(1), white(2), blue(3), red(4), white(5)]
=>
[red(1), red(4), white(2), white(5), blue(3)]

color(H) -> R, -> W, ->B

    dutch(L, RWB).
    dutch(L, RWB) :-
      distr_dl(L, dl(RWB, WB), dl(WB, B), dl(B, [])).

    distr_dl([red(H)|T], dl(red(H)|R), R1), W, B) :-
      distr_dl(T, dl(R, R1), W, B).

    distr_dl([white(H)|T], R, dl(white(H)|W), W1), B) :-
      distr_dl(T, R, dl(W, W1), B).

    distr_dl([blue(H)|T], R, W, dl(white(H)|B), B1)) :-
      distr_dl(T, R, W, dl(B, B1)).

    distr_dl([], dl(R, R), dl(W, W), dl(B, B)).

Дз - переписать это так, чтобы RWB, но в пределах каждого цвете инвертировать элементы.

## Нечёткая Логика ##

>см на бумаге

## 2я лекция ##

1) М, б\б, выступил лучше чем американец // clue
2) S, израильтянин, выступил лучше чем игрок в теннис
3)

structure = [ friend, (Name1, Country1, Sport1), ...]

did.letter = (M1C1, M2C1, Structure)

ДЗ1 - Задача Эйнштейна - имеется посёлок, в этом посёлке - 5 домов и каждый дом соответственно имеет свой цвет, в нём живёт владелец, у всех у них, владельцев, разные национальности, разные домашние животные, они предпочитают разные напитки и разные марки сигарет. По вербаальному описанию составить соответствующие структуры и подсунуть это всё на вход прологу. Это означает что есть список из пяти полей.

ДЗ2 - Головоломка о стабильных братах.

Для произвольного N

http://tcode.tinro.ru/ai/ | /cryptography

---

Задача - задание формирования плана, который за конечное количество действий переводит состояние из множества исходных состояний в множество заключительных состояний.

---

Задача про волка козу и капусту.
```
illegal([w, g], [c])
illegal([g, w], [c])
illegal([g, c], [w])
illegal([c, g], [w])
illegal([c], [w, g])
illegal([c], [g, w])
illegal([w], [g, c])
illegal([w], [c, g])

initial_state(wgc, wgc(left, [w, g, c], [])).

final_state(wgc(right, [], [w, g, c])).

move(wgc(left, L, R), Cargo) :-
    member(Cargo, L).

move(wgc(right, L, R), Cargo) :-
    member(Cargo, R).

move(wgc(B, L, R), nl).

update(wgc(B, L, R), Cargo, wgc(B1, L1, R1)) :-
  update(B, B1),
  update(Cargo, B, L, R, L1, R1).

update(right, left).
update(left, right).

update(nl, B, L, R, L1, R1).

update(Cargo, left, L, R, L1, R1) :-
  select(Cargo, L, L1),
  insert(Cargo, R, R1).

update(Cargo, left, L, R, L1, R1) :-
  select(Cargo, R, R1),
  insert(Cargo, L, L1).

insert(X, L, [X|L]).
```

ДЗ Три миссионера и три каннибала желают переправиться.
Имеется лодка. Может вести либо одного либо двух человек, проблема следующая если количество миссионеров превысит количество каннибалов на каком-то берегу, то тогда каннибалы....................тогда каннибалы, что, ну они становятся каннибалами. А, нет, давайте тогда первый вариант, если количество каннибалов превысит количество миссионеров, то да.
Нужно переправить шестерых персон, чтобы каннибалы никого не съели.

ДЗ2 Пять женатых пар. случилось наводнение и все они оказались на острове. И есть лодка. Которая может перевозить только максимум три человека за раз. Значит все аээээ мужья (задача про ревнивых мужей) они все ревнивые и не позволяют своим жёнам значит быть в лодке или на берегу с каким-нибудь другим, с какой-нибудь другой персоной мужского пола, ну или вообще с другими мужчинами, если он сам не присутствует в лодке или на берегу. Требуеттся осуществить эвакуация - перевести всех с острова на берег, удовлетворив всем этим ограничениям. В лодке 3 человека всегда.


## lecture n + 1 ##

Идея очень простая: есть банк и есть некий человек, который хочет занять в банке денег. Задача клерка - принять решение: дать кредит, не дать кредит или отправить надоплнительное рассмотрение. Мы будем делать экспертную систему = клерка на прологе.

3 фактора:

1. Залог:
  - деньги - хорошо
  - акции - норм
  - имущество - плохо для банка
2. Финансовая история
  - текущая прибыль от продаж
  - чистая стоймость (капитал) - стоймость всего минус обязательства
  - рост продаж
  - долги
3. доход банка

```
credit(Client, Answer)
C - collateral
F - finantial history 
Y - bank yield (доход банка)
```

Возможный ответ - да\нет\не знаю

```
Client -> C
collateral_rating
collateral_rating(Client, Rating):-
  collaterl_profile(Client, RC, SC, I).
  collateral_evaluation(FC, SC, I, Rating)
collateral_profile(Client, FC, SC, I) :- ???
```

ДЗ Взять пример из "Стирлинга и Шапиро" и сделать 
2. Модифицировать эту программу чтобы обеспечить такое свойство значит этой программы как результативность. То есть я имею в виду программы evaluate. Она результативна, если по любому профилю всегда возвращает ответ.
3. Написать программу, которая будет тестировать эту систему на свойство монотонности.

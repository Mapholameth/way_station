ls# Криптографические Методы Защиты Информации #

- системы с открытым ключём
- симметричное шифрование

криптография + криптоанализ = криптология

М - исходный текст (некоторый набор предложений на естественном языке)
=> преобразуется в крипто текст M - Message
C - крипто текст (C - cypher - крипто-текст)

- Схема Шэннона

`Источник сообщений` порождает некоторое сообщение `М`.
Имеется некоторый `канал`
Данный канал открыт для наблюдений злоумышленниками.
C = E(M, K) -> `канал`
-> С' -> дешифровка : M' = E^-1(C', K)

E^-1 ~ D(C, K) - Decryption

1. Закрытый канал связи
2. Стеганография
3. Схема Шэннона - известно всё кроме ключа

- Целостность
- Аутентичность
- Конфиденциальность

M in A*, A* - closure over alphabet A.
(M E=> C) in A* as well
M = m1..mn

- потоковые
- блочные

Если C = f(m1) .. f(mn) = c1..cn
тогда f:A <-> A - подстановка, взаимооднозначное отображение в исходный алфавит

Самая продстая подстановка - модулярный алгоритм т.е.
c = am + b mod {A}
GCD(a, |A|) = 1

# ДЗ1 #
Показать, что НОД(a, |A|) = 1 является необходимым и достаточным условием взаимооднозначности

# ДЗ2 #
Сколько всего модулярных шифров существует для заданного алфавита

# ДЗ3 #
см. на сайте последовательность всяких символов, - восстановить исходное М.
a = 1 - b - ?

> ОМОФОНЫ (Gauss)
> Сглаживание разнящихся частот кодированием одного и того же символа разными 
 
Ломается частотой встречаемости пар.

Тогда можно кодировать пары, тройки и так далее.

> Playfair crypt (шифр плейфеера(?) - позволяет удалить все частоты встречаемости пар символов
> 
> # ДЗ4 #
> Сколько различных криптосистем можно составить с использованием схемы плейфейр (5х5 матрица на торе) 


## Лекция 2 ##

M -> E = E(M, K)

c = am + b mod |A|

НОД(a, |A|) = 1

Шифр одноразового блокнота.
Абсолютно-криптостойкость. Шэннон.

for any K1, K2 There is K : E(E(M, K1), K2) = E(M, K) for any M

c1 = m1 + b0 mod |A|
c2 = m2 + c1 mod |A|

P{phi = M(i) } P{ psi = K(j) } P { ksi = C(l) }
P { ksi=C(l) | phi=M(i) } = P { ksi = C(l) } <=> абсолютная криптостойкость
т.е. это условие независимости вероятности события C(l) (криптованное сообщение) от исходного сообщения

M(i) - событие того, что наше сообщение приняло конкретный вид конкретного блока

c = A m + b mod |A|0 Шифр Хилла

НОД(det A, |A|) = 1

Эта штука скрывает закономерности символов, пар символов .. n-ок символов.

Уязвимость в том, что набор сообщений m образует вокруг А систему линейных уравнений, позволяющей найти матрицу А, поэтому данный подход не является криптостойким.

## Шифрование блоков ##

M |--------|-----------------------------------------|
  |--------|
     \/
   B = {0, 1}, B^2n

Мы должны взять все всевозможные наборы блоков и соотвественно для каждого из них записать соответствующий блок состоящий из ноликов и единиц. Тогда ключом будет ...? 

let n = 32 => size of key table = 32 * 2 ^ (64) ~ 10^21

## Блочные Симметричные Итеративные Шифры ##

Нам нужен первичный ключ Q, который позволяет однозначно сгенерировать всю таблицу. К сожалению это не взлетело. Но.

Количество возможных таблиц = (2^2n)!

Симметричные - это технологическое ограничение такого типа - схемы шифрования и дешифрования должны быть одинаковыми.

Итеративные - для зашифровки одно и то же преобразование проводится несколько раз.

DES, схема Файстеля 
Роундовое преобразование
x - block, x = (xl, xr). (of size n)
phi(x, q) : схема для зарисовки - так просто не запишешь :C => xr | xl + f(xr, q) // здесь + - сложение по модулю два

x^(t+1) = phi^F(x^t, q) = phi(F, q) x^t
(phi^F_q)^-1 -?

далее на доске вывод обратного и прямого чего-то там

ddef 1: (phi^F_q)^-1 = T_n phi^F _q T_n